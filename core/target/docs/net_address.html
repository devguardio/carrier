
<h1> module net::address </h1>
<h4> fn swap16 (

    u16
    x,

)

-&gt u16

</h4>

<p class='doc_comments'>

</p><h4> fn to_be16 (

    u16
    x,

)

-&gt u16

</h4>

<p class='doc_comments'>

</p><h4> fn from_be16 (

    u16
    x,

)

-&gt u16

</h4>

<p class='doc_comments'>

</p><h4> fn to_buffer (

    ::buffer::Buffer*+st
    to,

    usize
    st,

    ::net::address::Address*
    self,

)



</h4>

<p class='doc_comments'>
 append ip address to buffer, including port&lt;br&gt;
</p><h4> fn from_str_ipv4 (

    ::net::address::Address*
    self,

    ::ext::&lt;stddef.h&gt;::char*
    s,

    usize
    slen,

)

-&gt bool

</h4>

<p class='doc_comments'>
 parse a char * with len to an ipv4 address&lt;br&gt;&lt;br&gt; will fail for ipv6 address&lt;br&gt;
</p><h4> fn get_ip (

    ::net::address::Address*
    self,

)

-&gt u8*

</h4>

<p class='doc_comments'>
 get ip address as raw bytes.&lt;br&gt;&lt;br&gt; length depends on self-&gt;typ&lt;br&gt;  - ipv4 is 4  bytes long&lt;br&gt;  - ipv6 is 16 bytes long&lt;br&gt;
</p><h4> fn get_port (

    ::net::address::Address*
    self,

)

-&gt u16

</h4>

<p class='doc_comments'>
 get port number&lt;br&gt;&lt;br&gt; returns 0 if address does not have a port&lt;br&gt;
</p><h4> fn eq (

    ::net::address::Address*
    self,

    ::net::address::Address*
    other,

)

-&gt bool

</h4>

<p class='doc_comments'>
 compare equality between two addresses&lt;br&gt;
</p><h4> fn from_cstr (

    ::ext::&lt;stddef.h&gt;::char*
    s,

    ::net::address::Address*
    self,

)



</h4>

<p class='doc_comments'>
 parse a char * to an address&lt;br&gt;&lt;br&gt; same as from_buffer&lt;br&gt;
</p><h4> fn from_str (

    usize
    slen,

    ::ext::&lt;stddef.h&gt;::char*
    s,

    ::net::address::Address*
    self,

)



</h4>

<p class='doc_comments'>
 parse a char * with len to an address&lt;br&gt;&lt;br&gt; same as from_buffer&lt;br&gt;
</p><h4> fn set_port (

    ::net::address::Address*
    self,

    u16
    port,

)



</h4>

<p class='doc_comments'>
 set port number&lt;br&gt;
</p><h4> fn from_buffer (

    ::buffer::Buffer*+st
    s,

    ::net::address::Address*
    self,

    usize
    st,

)



</h4>

<p class='doc_comments'>
 parse a buffer to an address&lt;br&gt;&lt;br&gt; both ipv4 and ipv6 with and without port are supported&lt;br&gt;&lt;br&gt; valid examples:&lt;br&gt;  - 192.168.0.1:8080&lt;br&gt;  - 1.1.1.1&lt;br&gt;  - [2001:4860:4860::8888]:9000&lt;br&gt;  - [10f::]:9000&lt;br&gt;  - 2003:fb:ef05:6000:6000:9a6a:dd59:1234&lt;br&gt;
</p><h4> fn ip_to_buffer (

    ::buffer::Buffer*+st
    to,

    ::net::address::Address*
    self,

    usize
    st,

)



</h4>

<p class='doc_comments'>
 append ip address to buffer, excluding port&lt;br&gt;
</p><h4> fn set_ip (

    ::net::address::Type
    t,

    u8*
    b,

    ::net::address::Address*
    self,

)



</h4>

<p class='doc_comments'>
 set ip address from raw bytes.&lt;br&gt;&lt;br&gt; length depends on self-&gt;typ&lt;br&gt;  - ipv4 is 4  bytes long&lt;br&gt;  - ipv6 is 16 bytes long&lt;br&gt;
</p><h4> fn none (

    ::net::address::Address*
    self,

)



</h4>

<p class='doc_comments'>
 make an invalid network address&lt;br&gt;
</p><h4> fn valid (

    ::net::address::Address*
    self,

)

-&gt bool

</h4>

<p class='doc_comments'>
 check if address is valid&lt;br&gt;
</p><h4> fn from_str_ipv6 (

    ::ext::&lt;stddef.h&gt;::char*
    s,

    ::net::address::Address*
    self,

    usize
    slen,

)

-&gt bool

</h4>

<p class='doc_comments'>
 parse a char * with len to an ipv6 address&lt;br&gt;&lt;br&gt; will fail for ipv4 address&lt;br&gt;
</p>
















