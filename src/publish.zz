using <stdio.h>::{printf};
using <string.h>::{memcpy, memset};
using <assert.h>::{assert};
using <stdlib.h>::{exit};
using err;
using channel;
using router;
using bootstrap;
using io::unix;
using net;
using io;
using time;
using endpoint;
using router;
using hex;
using log;
using pq;
using byteorder;
using identity;
using protonerf;
using string;
using stream;
using slice;
using net::address;
using hpack;
using slice::{Slice};
using peering;
using proto;
using noise;
using responder;


static stream::Config PublishStream = stream::Config {
    path:   "/carrier.broker.v1/broker/publish",
    stream: stream_to_publish,
    close:  close_publish,
};


export fn publish(endpoint::Endpoint mut*self, err::Err+et mut*e)
    where err::checked(*e)
{
    self->broker_stream_registry[0] = &PeerConnect;

    stream::Stream mut* streami = self->broker()->open(e, &PublishStream);
    if err::check(e) {
        return;
    }
    static_attest(safe(streami));
    streami->user2 = self;
}

fn close_publish(stream::Stream mut *self) {
    log::error("publish closed\n");
    err::assert_safe(self->chan);
    err::assert_safe(self->chan->endpoint);
    self->chan->endpoint->close();
}

fn stream_to_publish(stream::Stream mut *self, err::Err+et mut*e, Slice *bs) -> bool
    where err::checked(*e)
{
    static_attest(safe(self->chan));
    if self->state == 0 {
        log::debug("publish response headers:");
        new it = hpack::decoder::decode(bs);
        while it.next(e) {
            log::debug("  %.*s: %.*s", it.key.size, it.key.mem, it.val.size, it.val.mem);
        }
        if err::check(e) {
            return false;
        }


        slice::MutSlice mut * frame = self->chan->q.alloc(e, channel::FrameType::Stream, 100);
        if err::check(e) {
            return false;
        }

        self->state = 1;

        frame->push32(byteorder::to_be32(1)); // stream
        frame->push64(byteorder::to_be64(2)); // order
        frame->push16(0); // size placeholder

        static_attest(safe(self->chan->endpoint));

        protonerf::encode_bytes(frame, e, 1, self->chan->endpoint->config.network.k, 32);
        if err::check(e) {
            return false;
        }
        protonerf::encode_bytes(frame, e, 2, self->chan->endpoint->config.network.k, 32);
        if err::check(e) {
            return false;
        }

    } else if self->state == 1 {
        // the only message after headers is supersede
        // TODO stop endpoint
    }

    return true;
}

static stream::Config PeerConnect = stream::Config {
    path:       "/carrier.broker.v1/peer/connect",
    open:       on_remote_open,
    stream:     stream_connect,
};


pub fn on_remote_open(stream::Stream mut*self, err::Err+et mut*e, void mut *user_config, slice::Slice *headers)
    where err::checked(*e)
{
    self->user2 = user_config;

    static_attest(safe(self->chan));
    let mut *frame = self->stream(e, 14);
    if err::check(e) { return; }

    hpack::encoder::encode(frame, e, (u8*)":status", 7, (u8*)"200", 3);
    if err::check(e) { return ; }
}

fn stream_connect(stream::Stream mut *self, err::Err+et mut*e, slice::Slice * msg) -> bool
    where err::checked(*e)
    where safe(msg->mem)
{
    static_attest(safe(self->chan));

    if self->state == 0 {
        self->state = 1;
        identity::Identity mut ii = {0};
        bool mut has_identity = false;
        slice::slice::Slice mut handshake = {0};
        u64 mut timestamp = 0;
        u64 mut route     = 0;
        peering::Peering mut peerings = {0};
        memcpy(&peerings, &self->chan->peering, sizeof(peering::Peering));


        let mut dec = protonerf::decode(proto::PeerConnectRequest, msg->mem, msg->size);
        for (;;) {
            let field = dec.next(e);
            if err::check(e) {
                return true;
            }
            if !field.valid {
                break;
            }
            switch field.index {
                proto::PeerConnectRequestField::Identity => {
                    if field.a == 0 || field.value.v_len != 32 {
                        err::fail(e, 1, "unexpected proto wire");
                        return false;
                    }
                    memcpy(ii.k, field.a, 32);

                    char mut m[60];
                    usize l = identity::identity_to_str(e, m, 60, &ii);
                    if err::check(e) {
                        return true;
                    }
                    log::info("connect request from identity %.*s", (int)l, m);
                    has_identity = true;
                }
                proto::PeerConnectRequestField::Timestamp => {
                    timestamp = field.value.v_u64;
                }
                proto::PeerConnectRequestField::Handshake => {
                    handshake.mem  = field.a;
                    handshake.size = field.value.v_len;
                }
                proto::PeerConnectRequestField::Route => {
                    route = byteorder::to_be64(field.value.v_u64);
                }
                proto::PeerConnectRequestField::Paths => {
                    peerings.from_proto(e, field);
                    if err::check(e) {
                        return true;
                    }
                }
                default => {
                }
            }
        }

        if !has_identity || handshake.mem == 0 || timestamp == 0 || route == 0 {
            err::fail(e, 13, "missing protobuf field");
            return true;
        }
        static_attest(len(handshake.mem) >= handshake.size);

        // unfortunate misdesign of tunneling an entire init packet
        // which actually contains no interesting information
        if handshake.size < 1 + 3 + 8 + 8 + 32 + 16 + 3 + 32 + 8 {
            err::fail(e, 1, "too small");
            return true;
        }
        handshake.mem  = handshake.mem  + (1 + 3 + 8 + 8);
        handshake.size = handshake.size - (1 + 3 + 8 + 8);

        noise::Responder mut rsp = {0};
        identity::secret_generate(&rsp.ephemeral, e);
        rsp.receive_insecure(
                (u8*)endpoint::PROLOGUE,
                static(len(endpoint::PROLOGUE)),
                handshake.mem,
                handshake.size - 64
        );
        if err::check(e) {
            return true;
        }



        // match the handshake identity with the broker
        let mut id = handshake;
        id.mem  = id.mem  + 32;
        id.size = 32;
        if !id.eq_bytes(ii.k, 32) {
            err::fail(e, 13, "identity mismatch");
            return true;
        }


        self->user1 = route;


        log::error("signature check not implemented, accepting everything");
        //FIXME compare route
        //FIXME check signature

        static_attest(safe(self->chan->endpoint));
        let authorized = self->chan->endpoint->config.authorize_connect(&ii);

        if !authorized {
            let mut *frame = self->chan->q.alloc(e, channel::FrameType::Stream, 34);
            if err::check(e) {
                return false;
            }
            frame->push32(byteorder::to_be32(self->id));
            frame->push64(byteorder::to_be64((self->order_outgoing)++));
            frame->push16(0); // size placeholder

            protonerf::encode_varint(frame, e, proto::PeerConnectResponseField::Ok, 0);
            if err::check(e) {
                return true;
            }
            protonerf::encode_bytes_start(frame, e, proto::PeerConnectResponseField::Handshake , 0);
            if err::check(e) {
                return true;
            }
            protonerf::encode_bytes(frame, e, proto::PeerConnectResponseField::Error, (u8*)"not authorized", 14);
            if err::check(e) {
                return true;
            }

            self->close();
            return true;
        }



        // the packet is ok from here and will be responded to
        endpoint::Endpoint mut * ep = self->chan->endpoint;
        err::assert_safe(ep);
        let nuchan = ep->statem.connected.next_channel();

        slice::MutSlice mut * mut frame = self->chan->q.alloc(e, channel::FrameType::Stream, 290);
        if err::check(e) {
            e->eprint();
            unsafe { frame = 0; }
            e->make();
        }

        // oom
        if nuchan == 0 || frame == 0 {
            log::error("oom");

            let mut *frame = self->chan->q.alloc(e, channel::FrameType::Stream, 30);
            if err::check(e) {
                return false;
            }
            frame->push32(byteorder::to_be32(self->id));
            frame->push64(byteorder::to_be64((self->order_outgoing)++));
            frame->push16(0); // size placeholder

            protonerf::encode_varint(frame, e, proto::PeerConnectResponseField::Ok, 0);
            if err::check(e) {
                return true;
            }
            protonerf::encode_bytes_start(frame, e, proto::PeerConnectResponseField::Handshake , 0);
            if err::check(e) {
                return true;
            }
            protonerf::encode_bytes(frame, e, proto::PeerConnectResponseField::Error, (u8*)"out of mem", 10);
            if err::check(e) {
                return true;
            }

            self->close();
            return true;
        }
        static_attest(safe(nuchan));

        frame->push32(byteorder::to_be32(self->id));
        frame->push64(byteorder::to_be64((self->order_outgoing)++));
        frame->push16(0); // size placeholder

        protonerf::encode_varint(frame, e, proto::PeerConnectResponseField::Ok, 1);
        if err::check(e) {
            return true;
        }


        // handshake, full packet version 0x08
        protonerf::encode_bytes_start(frame, e, proto::PeerConnectResponseField::Handshake, 252);
        if err::check(e) {
            return true;
        }

        static_attest(len(frame->slice.mem) > frame->at);
        static_attest(len(frame->slice.mem) > frame->at + 252);
        static_attest(safe(self->chan->store));
        responder::accept_insecure(
            &rsp,
            e,
            (identity::Secret*)&self->chan->store->secret,
            route,
            timestamp,
            frame
        );
        if err::check(e) {
            return true;
        }

        //TODO paths

        protonerf::encode_bytes(frame, e, proto::PeerConnectResponseField::Error, (u8*)"",0);
        if err::check(e) {
            return true;
        }

        log::info("accepted %zu %lu\n", frame->at, route);

        *nuchan = channel::from_symmetric(&rsp.symm, 0x08, route, true);
        nuchan->q.allocator = self->chan->q.allocator;
        nuchan->store       = self->chan->store;
        nuchan->endpoint    = self->chan->endpoint;
        memcpy(&nuchan->peer,  &ii, sizeof(identity::Identity));
        memcpy(&nuchan->peering, &peerings, sizeof(peering::Peering));

    } else {
        log::error("broker error in peer connect");
        hex::dump_slice(msg);
        new it = hpack::decoder::decode(msg);
        while it.next(e) {
            log::error("  %.*s: %.*s", it.key.size, it.key.mem, it.val.size, it.val.mem);
        }

    }
    return true;

}

pub fn cleanup_dead_route(channel::Channel mut * chan, u64 dead_route)
{
    for (usize mut i = 0 ; i < static(len(chan->streams)); i++) {
        if chan->streams[i].user1 == dead_route {
            chan->streams[i].closing = true;
        }
    }
}



